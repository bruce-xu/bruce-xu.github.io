---
layout: post
title:  移动端页面布局
date:   2017-07-21 00:00:00 +0800
categories: [Web App, CSS, Layout]
permalink: blogs/webapp/layout
tags: hybrid
keywords: Web App,CSS,Layout
---

　　开发 PC 站点时，相对来说，布局会简单一些。目前多数站点都会采用固定宽度布局，居中显示，两边留白。这样在绝大部分屏幕上显示都没问题，即便是极少数的窄屏上，最多出现横向滚动条，也不至于有大的问题。再多做一步的话，可以做成响应式的，设置几个临界点最大宽度，判断当前屏幕宽度小于某一临界值时，使用更小的一级最大宽度。可以使用 CSS 的媒体查询，若低版本浏览器不支持媒体查询时，可借助 JS 实现。采用固定宽度布局时，基本可以百分之百还原视觉稿。

　　但开发移动端站点时，会有些麻烦。由于移动设备屏幕千奇百怪，仅苹果全家桶从 iPhone 4 到 iPhone 7 就有 320、375、414 像素屏幕宽度（此处说的是 CSS 像素，也叫逻辑像素或设备独立像素，不同于物理像素，下同），Android 设备就更不用说了，碎片化相当严重。虽然 PC 的屏幕也是各种尺寸，但如上面所说，可以通过固定宽度布局然后居中显示来解决。但移动端设备屏幕本身就很小，如果也采用固定宽度布局的话，在稍大屏上会导致两边留白，不能充分利用有限的屏幕空间；在稍小屏上又会出现横向滚动条，移动端的横向滚动条会导致体验很差。所以此方案行不通。

　　想在手机上访问 PC 站点，如果不做任何处理，肯定会有问题，因为常规手机 300 多 CSS 像素的屏幕上肯定显示不下 1000 像素左右宽度的内容，必然会出现水平滚动条。所以设备厂商想了个办法：整出了个 layout viewport 的概念，在这个虚拟窗口中显示网页。iPhone 下，设置的 layout viewport 的宽度是980px（至于为什么是 980px，可能是由于当时大部分的 PC 页面在这个宽度范围吧），Android 下大部分是 800px，个别机型可能会不同。由于屏幕实际的 CSS 像素要小得多，所以 layout viewport 显示 PC 内容时，只能缩放内容，这样大部分 PC 站点可以在手机上完全展示（个别宽度大于 980px 的站点还是会有水平滚动条）。其实这也只是一个自欺欺人的做法，虽然这时页面基本可以完全展示，但由于默认进行了缩放，基本不具有可读性，还需要用户手动放大内容，才能方便阅读。于是苹果又带头整了个新的功能：双击屏幕放大内容。由于放大了内容，这时横向滚动条依旧会出现。绕了一圈又回到了原点，而且由于提供了双击放大的功能，又带来了一个问题：如果双击区域内有可点击的内容怎么办？如有个链接，怎么才能知道用户是想双击放大，还是想点击链接跳转。正常情况下点击事件会立刻触发，而用户手指双击时，两次点击总会有时间间隔。如不加处理，在第一次点击屏幕时，就会触发点击链接事件跳转走了，而不会触发双击了。所以为了解决此问题，苹果又带头引入了 300ms 延迟方案，即单击屏幕后，延后 300ms 才触发 click 事件。之所以使用 300ms ，可能是由于统计发现大多数人的双击操作会在 300ms 内完成吧。如果在此时间段内双击了屏幕，就会缩放屏幕，而不会触发 click 事件。由于 click 事件在移动端会有 300ms 的延迟，导致直接使用时会有问题，因为交互后 100ms 的延迟，就会被用户感知到，会产生卡顿的感觉。于是又产生了新的解决方案，引入第三方的工具：FastClick。FastClick 也解决了 300ms 延迟触发 click 事件带来的另一问题：点击穿透，此处就不深入介绍了。

　　由上述可知，手机端浏览器直接加载 PC 页面是有问题的，所以越来越多的站点会提供移动端的版本。为了标识当前页面是为移动端设计，而不是作为 PC 页面加载，而使 layout viewport 会被自动缩放，需要为页面增加特殊的 meta 标签：

``` html
  <meta name="viewport" content="width=xxx">
```

　　这样浏览器就会以 meta 标签中`width=xxx`的值设置 layout viewport 的宽度。可以使用`width=320`这样的固定值，也可以是`width=device-width`这样的适配当前屏幕的相对值。早期不少移动端站点会使用固定值，如之前所在的公司携程的 m 站使用的就是`width=320`（不过现在已变成了`width=device-width`）。使用固定值的好处是，适配比较简单，可以直接使用 px 作为单位，视觉稿上是多大，就可以设置成多大，基本可以百分之百还原视觉稿。但坏处是不同屏幕的手机下显示效果有差别，可以想象 360px 宽的屏幕被当成 320px 用，会有内容被放大的感觉，而小屏幕上会感觉到内容被缩小。好在当时屏幕尺寸没有现在这么夸张，虽有差别但不大，所以使用一种常见的屏幕宽度来布局，问题不大。

　　但随着移动设备屏幕越来越多样化，如从 iPhone 4 到 iPhone 7 plus，屏幕宽度跨度就从 320px 到 414px，变化很大，更不要提五花八门的 Android 设备了。所以设置 layout viewport 为固定宽度已无法适配各种屏幕，目前的移动端站点基本都通过`width=device-width`来设置 layout viewport，即用当前设备的宽度来作为 layout viewport 的宽度。这样页面在各种设备上看起来比例都还好，不会有被缩放的感觉。但使用`width=device-width`又会带来新的问题：通常只会有一套特定宽度的视觉稿，但屏幕宽度却五花八门，如何适配它们呢？

　　仅仅使用 px 作为单位显然是不行了，这就会导致要么出现横向滚动条，要么页面留白。使用 CSS3 中的 flex 布局，外加 CSS 媒体查询，再使用 px 作为单位，倒是可以解决一些布局问题，但仍不是一个通用的方案。CSS3 中增加的 rem 单位可以弥补 px 的一些不足。rem 虽然与之前就有的 em 单位很像，但它们有着本质区别：em 是相对于父元素的，而 rem 是相对根元素的（即 html 元素）。所以使用时需要给 html 根元素设置`font-size`，这样子元素使用 rem 作为单位时，就是相对于根元素的大小了。适配不同屏幕时，只需要根据不同屏幕的宽度，给 html 根元素设置不同的`font-size`，相关的布局就会随着窗口的变化而变化了。

　　也许你会问：这和使用百分比的相对布局有什么区别？百分比还是相对于父元素的，当元素嵌套比较多时，计算百分比将相当麻烦，而且元素嵌套结构一变化，之前的计算将乱套，无法维护。

　　也许你还会问：这和给 meta 设置`width=320`这类固定宽度布局有什么不同？诚然，如果给所有元素都使用 rem 作为单位，这和将 layout viewport 设置为设计稿匹配的固定宽度（640px 的视觉稿，则设置`width=320`；750px 的视觉稿，则设置`width=375`），然后使用 px 作为单位，从效果上看，也没什么不同，都是等比缩放视觉稿。只不过前者是 layout viewport 变化，缩放其中的内容，后者是先缩放 layout viewport 为固定值，内容大小固定。

　　所以，即便 rem 作为单位很实用，但也不是放之四海而皆准，还需要具体情况具体分析。例如，一般情况下，文本字体大小就不推荐使用 rem 作为单位，一是由于点阵字体推荐使用偶数来设置大小，奇数有时会影响渲染效果，而使用 rem 时，不仅可能会有奇数，甚至会计算出小数，影响效果。二是由于使用 rem 设置文本字体时，字体大小会随着屏幕 CSS 像素的增大而增大。例如假设在 320px 的屏幕上字体设置成 14px 效果正好，这是每行可以显示 20 个字，而如果用 640px 的屏幕设备加载页面，字体大小将变成 28px，这时页面也仅显示了 20 个字。显然这不是我们想要的，我们希望在大屏下可以显示更多的文字。虽然一般情况下，更大的 CSS 像素宽度，都会有着更大的像素密度，导致相同像素的字体大小在大的 CSS 像素屏幕上会看起来更小些，需要增大字体大小，才能与小的 CSS 像素屏幕上看到的效果一致，但也仅仅是适当的增大一点点，绝不是成比例的增大。所以从这方面看，字体大小也不宜使用 rem 作为单位。

　　所以合理的方案应该同时使用 px、rem 甚至百分比等作为单位（vw、vh 也是很好的选择，如果不存在兼容性问题的话），同时以 flex 甚至 float 等辅助，来完成布局。具体怎么选择，应该具体问题具体分析，没有一劳永逸的方案。

　　如果要用到 rem 的话，那么该如何使用呢？既然 rem 是以页面根元素（即 html 元素）的 font-size 为基准的，那么关键点就落在了如何设置 html 的 font-size 上了。肯定不能写死为特定的一个值，rem 最大的特点就在于其动态性，这样使用 rem 就失去了意义，和 px 没有什么区别了，应该根据屏幕宽度动态计算。假设将屏幕宽度分成十等份，将每一等份看成 1rem，即屏幕宽度为 10rem。可以通过如下方式动态计算：

``` javascript
var docEl = document.documentElement;
var rem = docEl.clientWidth / 10;
docEl.style.fontSize = rem + 'px';
```

　　同时也将设计稿看成十等份，假设设计稿是 750px 宽度，则一等份为 75px。那么页面上的 1rem 就对应了设计稿上的 75px，假设设计稿上某一区域的宽高皆为为 150px，则书写样式时，就可以这样写：

``` css
width: 2rem;
height: 2rem;
```

　　则在不同大小的屏幕上，此块区域始终占据着相同比例的空间。这样，通过设置根元素的 font-size，建立了页面与设计稿之间的联系。上面是将屏幕宽度分成十等份，总宽度当成 10rem。这样做只是为了计算方便，理论上可以分成任意等份，如 100。但分成 100 份是有问题的。如在 320px 的屏幕下，需要设置 html 元素的 font-size 为 3.2px。在 PC 端的 webkit 内核的浏览器中，限制最小的字体为 12px，当设置更小值时，会被强制转化成 12px，虽然很早前可以通过设置 -webkit-text-size-adjust: none; 来解决，但带来了无法缩放的问题，后来被当成 bug 解决了，-webkit-text-size-adjust 也就失效了。虽然网上都说移动端 webkit 浏览器上支持设置小于 12px 的字体，试了 iOS 下确实可以，但在 Android 上，至少在我的手机上的 Chrome（版本为56）不支持，仍旧将小于 12px 的字体显示为 12px。其它 Android 系统及其它浏览器没有试，但只要有一个常见的不满足，就是个问题，需要避免这样使用。另外，需要说明的是，在 PC 上最新的 Chrome（版本为 59）中，发现居然可以支持小于 12px 的字体了，现在将限制降低到了 8px。同时我将手机上的 Chrome 升级到 59 版本后，发现也最小支持到了 8px 的字体。这个世界变化太快，网上的那些文章又都要过时了。

　　